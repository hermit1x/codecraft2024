# 2024 华为软件挑战赛

## 杂七杂八的idea

* 寻路：机器人无非就两种状态，拿着货去找船/空手去找货，这里可以通过以泊位为源做一个全图最短路，这样任意一个点就可以通过在这个距离曲面上不停的“下降”来到达泊位。机器人在泊位放完东西也可以用这个方式反演一下从物品到泊位的路径，O(n) 获得最短路。
* 碰撞协商：撞墙撞海从指令上就该解决，不发出非法指令。互相碰撞打算以私下协商为主，即两个机器人先各种做出移动的志愿，然后综合统计一下大家这种移动方式会不会碰撞。会的话使用一定优先级来让行，比如有货的优先，id小的优先。商讨之后作出让步。
* 路径记录：现在实现了两种记录路径的方法，一种是使用一个vector记录每一次要走的方向，另一种是自行进行前文说的“下降”，即不显示的预处理路径。
* 时间管理：机器人在有明确的运货指标后，如不出意外，最后到达泊位卸货的时间是可以预知的，可以把这个信息加入船舶调度的算法中。同时这一个题目框架下算法对“未来”的预估信息是相当准确的，应该利用好这一点。
* 宏观调控：目前有几个想法
  * 船停在什么泊位要看泊位产生的收益，除了独立计算这个点离各个货物的距离，还要考虑船船之间是不是要分散一点
  * 机器人是要在指定目标后坚定的执行吗，如果走一半出现了更合适的要怎么处理？
  * 船要等装满了再走，还是提高轮转率？

## 实现思路

### 地图
地图使用一个类```Mat```来存，实例化为```mat[200][200]```，其中```type```正常记录地形类型，```dist```的十层分别是十个泊位的距离曲面，在初始化的时候通过十次Dijkstra算法计算。

```cpp
enum mat_enum { LAND, OCEAN, HILL, BERTH };
class Mat {
public:
    mat_enum type;
    int dist[berth_num];
} mat[207][207];
```

配套函数有这两个，一个防止下标溢出，一个确定是可以走的地图。

```cpp
inline bool in_mat(int x, int y) {
    return 0 <= x && x < 200 && 0 <= y && y < 200;
}
inline bool is_land(int x, int y) {
    return mat[x][y].type == LAND || mat[x][y].type == BERTH;
}
```

### 机器人

施工中

### 碰撞协商

经过多种方案测试，最后选择比较简单的碰撞协商算法。

首先是一个判断，如果机器人的曼哈顿距离3以内没有别的机器人，就一定不会发生碰撞，这时候机器人想怎么走就怎么走，这里使用```is_safe```变量来记录。

对于不安全的机器人，先正常判断它能往哪里走，把所有可行的下一步放入```next_moves```的```vector```数组，同时附带对它的期望值。并对这一个数组进行排序。

接着进行分组，把相互曼哈顿距离为3以内的机器人分为一组，一组以内可以有2~10个机器人，组的个数也是每一帧动态变化的。

规划机器人的优先级，手上有货的优先，若都有、都没有，则id小的优先。

然后对每一组以内进行DFS碰撞控制，通过两张图（现在、下一步）进行碰撞避免。使用DFS遍历组内每一个机器人的需求，若没有冲突就记录在地图上，并告诉机器人可以这么走，如果有就回溯，更改高优先级机器人的选择。由于前面对于```next_moves```进行排序，这种方式可以在组织大家时尽可能让每个机器人都走最优的一步。

至于为什么要分组，是如果把所有机器人放在一起进行dfs纠错，会导致搜索树很大，慢。互相之间没有影响的一个个组完全可以在组内协商好，组内协调好了全局也不会发生碰撞。

### 泊位、船只

```cpp
enum ship_enum { SHIPPING, NORMAL, WAITING };
class Berth {
public:
    Berth() {}

    int id, pos_x, pos_y, transport_time, velocity;
}berth[berth_num+1];

class Ship {
public:
    Ship() {};

    ship_enum status;
    int berth_id;
    int loads;
} ship[ship_num+1];

int ship_capacity;
```

### 寻路
