# 2024 华为软件挑战赛

## 杂七杂八的idea

* 寻路：机器人无非就两种状态，拿着货去找船/空手去找货，这里可以通过以泊位为源做一个全图最短路，这样任意一个点就可以通过在这个距离曲面上不停的“下降”来到达泊位。机器人在泊位放完东西也可以用这个方式反演一下从物品到泊位的路径，O(n) 获得最短路。
* 碰撞协商：撞墙撞海从指令上就该解决，不发出非法指令。互相碰撞打算以私下协商为主，即两个机器人先各种做出移动的志愿，然后综合统计一下大家这种移动方式会不会碰撞。会的话使用一定优先级来让行，比如有货的优先，id小的优先。商讨之后作出让步。
* 路径记录：现在实现了两种记录路径的方法，一种是使用一个vector记录每一次要走的方向，另一种是自行进行前文说的“下降”，即不显示的预处理路径。
* 时间管理：机器人在有明确的运货指标后，如不出意外，最后到达泊位卸货的时间是可以预知的，可以把这个信息加入船舶调度的算法中。同时这一个题目框架下算法对“未来”的预估信息是相当准确的，应该利用好这一点。
* 宏观调控：目前有几个想法
  * 船停在什么泊位要看泊位产生的收益，除了独立计算这个点离各个货物的距离，还要考虑船船之间是不是要分散一点
  * 机器人是要在指定目标后坚定的执行吗，如果走一半出现了更合适的要怎么处理？
  * 船要等装满了再走，还是提高轮转率？

## 实现思路

### 地图
地图使用一个类```Mat```来存，实例化为```mat[200][200]```，其中```type```正常记录地形类型，```dist```的十层分别是十个泊位的距离曲面，在初始化的时候通过十次Dijkstra算法计算。

```cpp
enum mat_enum { LAND, OCEAN, HILL, BERTH };
class Mat {
public:
    mat_enum type;
    int dist[berth_num];
} mat[207][207];
```

配套函数有这两个，一个防止下标溢出，一个确定是可以走的地图。

```cpp
inline bool in_mat(int x, int y) {
    return 0 <= x && x < 200 && 0 <= y && y < 200;
}
inline bool is_land(int x, int y) {
    return mat[x][y].type == LAND || mat[x][y].type == BERTH;
}
```

### 机器人

施工中

预期目标：
* 每个机器人自带move处理，包括先存着移动志愿，冲突处理完后打印指令、同时记录到robot自身的xy中
* 每次读取当前机器人信息的时候比对一下记录的信息，如果不同还要加入处理
* 可以先从那个移动vector中读，没有就进行梯度下降（可以再研究）

### 碰撞协商

### 泊位、船只

```cpp
enum ship_enum { SHIPPING, NORMAL, WAITING };
class Berth {
public:
    Berth() {}

    int id, pos_x, pos_y, transport_time, velocity;
}berth[berth_num+1];

class Ship {
public:
    Ship() {};

    ship_enum status;
    int berth_id;
    int loads;
} ship[ship_num+1];

int ship_capacity;
```

### 寻路
